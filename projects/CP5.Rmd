---
title: "CP5"
author: "Bruce Phillips"
date: '2022-09-27'
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
library(Matrix)
```

Generate the Hilbert matrix and choose b; solve for various n:
```{r}
n<-seq(1,12,1)
for (i in n ) {
  a<-Hilbert(i)
  x<-c(1,rep(0,i-1))
  b<-as.vector(a[,1])
  s<-as.vector(solve(a,b))
  print(s)
  print(eigen(a)['values'])
}
```

The solve only seems to work for Hilbert matrices up to size 12, but does give an accurate solution up to that size. We can see why this might be happening; as n increases the smallest eigen-values approach zero very fast and after n=12, it must be that at least one is close enough to zero for the solve function to deem the matrix uninvertible.

\newpage

The recurrence:
```{r}

inverse.hilbert<-function(i){
  h<-as.matrix(Hilbert(i))
  x<-c(1,rep(0,i-1))
  b<-h[,1]
  tr<-sum(diag(h%*%h))
  a0=h/tr
  I=diag(i)
  l0<-a0
  r0<-a0
  for(j in 1:100){
    l<-(2*I-l0%*%h)%*%l0
    l0<-l}
  for(j in 1:100){
    r<-r0%*%(2*I-h%*%r0)
    r0<-r}
  return(list('l0'=l0,'r0'=r0,'b'=b,'x'=x))
}
```
Note: it seems that the recurrence as given (the second one above) only computes a right-hand inverse for h. This is almost unoticable for very small values of n but the discrepancy becomes apparent quite quickly. For example:
```{r}
inv.test5<-inverse.hilbert(5)
inv.test5$r0 %*% Hilbert(5)

inv.test7<-inverse.hilbert(7)
inv.test7$r0 %*% Hilbert(7)


inv.test10<-inverse.hilbert(10)
inv.test10$r0 %*% Hilbert(10)

```
 When left multiplying, the given recurrence gives an 'inverse' that is passable as the true inverse for n=5. Even a slight increase in n causes the inverse to deteriorate and by n=10 it is unrecognizable as an inverse

However, using the slightly altered recurrence gives us a useable left-hand inverse:
```{r}
inv.test5<-inverse.hilbert(5)
inv.test5$l0 %*% Hilbert(5)

inv.test7<-inverse.hilbert(7)
inv.test7$l0 %*% Hilbert(7)


inv.test10<-inverse.hilbert(10)
inv.test10$l0 %*% Hilbert(10)
```

Since our goal is to uncover the solution to Hx=b, we will need to compute the left inverse:
```{r}
inv.test50<-inverse.hilbert(50)
inv.test100<-inverse.hilbert(100)
inv.test500<-inverse.hilbert(500) #this one takes a while
```

```{r}
#only showing top ten values of the solution
(inv.test50$l0 %*% inv.test50$b)[1:10] 
(inv.test100$l0 %*% inv.test100$b)[1:10] 
(inv.test500$l0 %*% inv.test500$b)[1:10] 
```
We see that the left-hand inverse generated by the recurrence is quite accurate as uncovering the solution to the system.
